varying vec3 normal, eyeVec;
#define MAX_LIGHTS 8
#define NUM_LIGHTS 3
varying vec3 lightDir[MAX_LIGHTS];
uniform sampler2D tex;

uniform bool ALOXrenderMode;
uniform bool glslFog;
uniform int glslTime;

void main (void)
{
  vec4 final_color = gl_FrontLightModelProduct.sceneColor;
  vec3 N = normalize(normal);
  //vec4 coloreTexture = texture2D(tex,gl_TexCoord[0].st);
  
  //disturbo:

  //pseudorandom
  //float rand = fract(sin(dot(gl_TexCoord[0].st ,vec2(12.9898,glslTime))) * 43758.5453);

  //vec2 distort = vec2(sin(gl_FragCoord.x/1.5),sin(gl_FragCoord.y*3.14*glslTime/400)); //*(rand);
  vec2 distort = vec2(0,sin(gl_FragCoord.y/4+3.14*(float(glslTime)/20.0)  ));
  vec4 coloreTexture = texture2D(tex,gl_TexCoord[0].st-distort/400);
  //vec4 coloreTexture = texture2D(tex,gl_TexCoord[0].st-vec2(rand*0.01,0) );

  //illuminazione diffusa lambertiana
  int i;
  //gl_FragColor = coloreTexture;
  //return;
  for (i=0; i<NUM_LIGHTS; ++i)
  {  
    vec3 L = normalize(lightDir[i]);
    float lambertTerm = dot(N,L);
    if (lambertTerm > 0.0)
    {
      //final_color += gl_LightSource[i].diffuse * gl_FrontMaterial.diffuse * lambertTerm;
      if(ALOXrenderMode) final_color += gl_LightSource[i].diffuse * coloreTexture * lambertTerm;
      else final_color += gl_LightSource[i].diffuse * gl_FrontMaterial.diffuse * lambertTerm;
    }
  }

  //seppia:
  float inputRed = final_color[0];float inputGreen = final_color[1];float inputBlue = final_color[2];
  float outputRed = (inputRed * 0.393) + (inputGreen *0.769) + (inputBlue * 0.189);
  float outputGreen = (inputRed * 0.349) + (inputGreen *0.686) + (inputBlue * 0.168);
  float outputBlue = (inputRed * 0.272) + (inputGreen *0.534) + (inputBlue * 0.131);
  final_color = mix(final_color,vec4(outputRed,outputGreen,outputBlue,final_color.a),0.35);



  //FOG:
  if (glslFog) {
  const float LOG2 = 1.442695;
  float z = max(0, gl_FragCoord.z / gl_FragCoord.w - 2.4); //2.4 = distanza inizio nebbia
  //ATTENZIONE con "gl_FragCoord.z / gl_FragCoord.w - 3.5" ero riuscito a ottenere no nebbia nell'area da calore
  float fogFactor = exp2( -gl_Fog.density * gl_Fog.density * z * z * LOG2 );

  gl_FragColor = mix(gl_Fog.color, final_color, fogFactor );
  }
  else {
    gl_FragColor = final_color;
  }
	
}



/*

uniform sampler2D tex;

void main( void )
{
vec4 color = texture2D(tex,gl_TexCoord[0].st);

gl_FragColor = color;
return;

float inputRed = color[0];float inputGreen = color[1];float inputBlue = color[2];
float outputRed = (inputRed * 0.393) + (inputGreen *0.769) + (inputBlue * 0.189);
float outputGreen = (inputRed * 0.349) + (inputGreen *0.686) + (inputBlue * 0.168);
float outputBlue = (inputRed * 0.272) + (inputGreen *0.534) + (inputBlue * 0.131);


//gl_FragColor = vec4(0.0,1.0,0.0,1.0);
//gl_FragColor = vec4(mix(color,vec4(outputRed,outputGreen,outputBlue,color[3]),0.5));
gl_FragColor = vec4(mix(color,vec4(inputRed,inputRed,inputRed*0.7,color[3]),0.7));

}

/*
void main (void)  
{     
   gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);  
}
*/
